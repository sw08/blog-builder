### [문제 링크](https://www.acmicpc.net/problem/9663)

### 태그
백트래킹, 재귀

### 문제 요약
N*N 크기의 체스판에 N개의 퀸을 서로 공격할 수 없게 놓기.

### 입출력 및 조건  
#### 입력
첫째 줄에 N(1 <= N < 15)이 입력됨.
#### 출력
첫째 줄에 모든 경우의 수를 출력함.
#### 조건
시간제한: 10초 / 메모리 제한: 128MB

### 문제들과 그 해결법
#### 첫 번째 문제: 시간 초과 (1)
##### 문제
에라토스테네스의 체를 이용해 소수를 구하는 방법과 비슷하게 착수시마다 남은 칸들에 착수 가능 여부를 저장해둠. 그러나 이 방식은 이미 착수 불가 칸으로 체크된 칸을 계속 검사했기에 시간 초과가 발생함.
##### 해결법
착수 가능 여부를 저장하지 않으며 대신 착수시에 가능 여부를 일일이 체크하도록 변경. 이 과정에서 인터넷의 풀이를 참고함.
#### 두 번째 문제: 시간 초과 (2)
##### 문제
위 알고리즘으로 수정하였으나 시간 초과가 계속 발생해 PyPy3으로 변경해 제출했음에도 여전히 시간 초과 발생.
##### 해결법
파이썬 대신 C99로 작성해 제출함. 원 풀이와 사실상 동일한 코드를 제출하였음을 고려할 때, 파이썬으로는 시간 내에 해결할 수 없었던 것으로 생각됨.

### 코드
```c
#include <stdio.h>
#include <stdlib.h>

int check(int *board, int row) {
  for (int y = 0; y < row; y++) {
    if ((abs(board[row] - board[y]) == abs(row - y)) || // 대각선 이동 범위 내 확인
        (board[row] == board[y])) { // 세로 이동 범위 내 확인
      return 0;
    }
  }
  return 1;
}

int get(int *board, int row, int n) {
  if (row == n)
    return 1;
  int c = 0;
  for (int x = 0; x < n; x++) {
    // row행의 퀸의 X좌표를 변경 후 착수 가능할 경우 재귀를 이용해 경우의 수 계산
    board[row] = x;
    if (check(board, row)) {
      c += get(board, row + 1, n);
    }
  }
  return c;
}
int main() {
  int n;
  int board[15] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; // 각 행별 퀸의 X좌표를 저장
  scanf("%d", &n);
  int result = get(board, 0, n);
  printf("%d", result);
}
```

### 코드 추가 해설  
##### L6 ~ L7
같은 행에 퀸이 위치하는 경우는 get 함수부터가 행당 한 개의 퀸만 위치하는 것을 전제로 작성되었기에 배제함.

### 답안 참고 여부
예