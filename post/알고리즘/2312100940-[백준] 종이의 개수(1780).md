### [문제 링크](https://www.acmicpc.net/problem/1780)

### 태그
분할 정복, 누적 합, 재귀

### 문제 요약
N*N 크기의 행렬로 표현되는 종이가 있음.  
종이의 각 칸에는 -1, 0, 1 중 하나가 저장됨.  
아래 규칙을 모든 종이가 만족할 때까지 반복함.  
###### (1) 모두 같은 수로 구성된 경우
그대로 사용함
###### (2) 모두 같은 수로 구성되지 않은 경우
종이를 9등분해 다시 검사함

### 입출력 및 조건  
#### 입력
첫째 줄에 N(N = 3^k, k는 0 이상 7 이하의 정수)이, 다음 N개 줄에는 N개의 정수가 공백으로 분리되어 입력됨.
#### 출력
각각 -1, 0, 1로 채워진 종이의 갯수를 한 줄에 하나씩 출력함.
#### 조건
시간제한: 2초 / 메모리 제한: 256MB

### 문제들과 그 해결법
#### 첫 번째 문제: 조건 (1)의 검사를 어떻게 할 것인가  
##### 문제
단순하게 생각한다면 모두 더해서 합을 확인해 보는 방법도 있었겠지만, 이렇게 할 경우 1회 확인 작업의 시간복잡도가 O(N)이므로 최악의 경우 총 34조 번(!) 연산을 수행해야 할 수도 있어 배제했다. 
##### 해결법
내 경우 백준의 단계별 풀어보기 목록을 순서대로 시도해 보던 중이었는데, 운이 좋게도 분할 정복의 바로 전전 단계가 누적합이었다. 이를 응용해 (i, j)번째 칸에는 (i, j)와 (0, 0)을 두 꼭짓점으로 하는 직사각형에 속하는 모든 칸의 합을 더하게 하였으며, 이로써 확인하는 과정을 사칙연산 4개로 줄였다. 즉, (a, b)부터 (c, d)까지의 합은 (c, d)까지의 누적합에서 (c, b - 1)까지의 누적합과 (a - 1, d)까지의 누적합을 빼준 후 중복으로 처리된 (a - 1, b - 1)까지의 누적합을 다시 더해주면 구할 수 있다.
![설명 그림](/files/3.svg)

#### 두 번째 문제: -1을 어떻게 처리할 것인가  
##### 문제
단순히 합만을 비교하는 것은 완전한 검사라 할 수 없는데, 이는 모두 0으로 이루어진 행렬과 1/-1이 동일한 갯수만큼 존재하는 행렬은 합이 둘 다 0으로 같았기 때문이다.
##### 해결법
나는 이를 -1을 10으로 치환해 계산함으로써 해결하였다. 10인 이유는 모두 1으로 이루어졌을 때와 혼동되지 않는 최소 수였기 때문이다(9 이하의 k의 경우 1이 k개일때와 혼동될 수 있음).

#### 세 번째 문제: 행렬을 어떻게 9등분할 것인가  
##### 문제
처음 이 문제의 코드를 [쿼드트리 문제](https://www.acmicpc.net/problem/2630)에서 사용했던 것을 조금 고쳐서 시도하였기 때문에, 행렬을 등분해 다시 확인하는 작업은 1차원 리스트를 슬라이싱해 재귀하는 방식으로 이루어졌다. 그러나 이는 행렬의 일부분을 복사해야 했으므로 메모리를 과도하게 소모하였을 뿐만 아니라 시간 또한 오래 걸리는 작업이었기에 이 문제에서는 사용이 불가능하였다.
##### 해결법
나는 이를 등분된 행렬이 아닌 범위를 재귀에 전달함으로써 해결하였다. 대신 행렬의 크기가 정해져 있지 않으므로 행렬의 가로 길이를 추가로 전달시켰다.

### 코드
```py
# N과 행렬을 입력받음
N = int(input())
board = [[0 for _ in range(N + 1)] for _ in range(N + 1)] # 인덱스를 1부터 시작함으로써 첫번째 입력의 예외처리와 추후에 발생할 수 있는 혼동을 방지.
for y in range(1, N + 1):
    temp = input().split()
    for x in range(1, N + 1):
        # 첫번째 문제 참고.
        board[y][x] = int(temp[x - 1].replace("-1", "10")) + board[y - 1][x] + board[y][x - 1] - board[y - 1][x - 1]

def get(x, y, l, count):
    x2, y2 = x + l - 1, y + l - 1
    summary = board[y2][x2] - board[y2][x - 1] - board[y - 1][x2] + board[y - 1][x - 1] # 총합
    if summary == 10 * l * l:
        count[0] += 1
    elif summary == 0:
        count[1] += 1
    elif summary == l * l:
        count[2] += 1
    else:
        for i in range(0, l, l // 3):
            for j in range(0, l, l // 3):
                get(x + i, y + j, l // 3, count)
    return count

print(*get(1, 1, N, [0, 0, 0]), sep="\n")
```

### 코드 추가 해설  
##### L8
`x`, `y`는 범위의 시작점의 좌표이며, `l`로 분할된 행렬의 가로 길이를 전달해 범위의 끝점을 구할 수 있도록 하였다.
##### L20
`l // 3`에서 `//`를 쓴 이유는 `/`이 float형을 반환하기 때문이다.
##### L21
`count`의 경우 재귀 과정에서 얕게 복사되기에 단순히 배열의 데이터를 조작하는 것만으로도 충분하나, L23의 데이터 출력을 위해 `return count`를 추가시켰다. 

### 답안 참고 여부
아니오